
<!DOCTYPE html>
<html lang="en">
<head>

	<title>NieR:Calculator</title>
	<meta name="title" content="NieR:Calculator" />
	<meta name="description" content="Convert your money into NieR:Automata copies" />
	<meta property="og:type" content="website" />
	<meta property="og:url" content="https://moshiax.github.io/NierCalculator/" />
	<meta property="og:title" content="NieR:Calculator " />
	<meta property="og:description" content="Convert your money into NieR:Automata copies" />
	<meta property="og:image" content="https://raw.githubusercontent.com/moshiax/NierCalculator/refs/heads/main/icons/meta.png" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
	<meta name="google-site-verification" content="o9KnKTL1pgRSckXmShW5N8Out0HkFHkA8vl8rA8tgIA" />
	<meta property="twitter:card" content="summary_large_image" />
	<meta property="twitter:url" content="https://moshiax.github.io/NierCalculator/" />
	<meta property="twitter:title" content="NieR:Calculator " />
	<meta property="twitter:description" content="Convert your money into NieR:Automata copies" />
	<meta property="twitter:image" content="https://raw.githubusercontent.com/moshiax/NierCalculator/refs/heads/main/icons/meta.png" />

    <link rel="icon" type="image/png" href="https://moshiax.github.io/NierCalculator/icons/logo.png">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
html {
  height: 100%;
  margin: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  -webkit-tap-highlight-color: transparent;
}

body {
  background-color: #d1cdb7;
  font-family: "Courier New", monospace;
  color: #fff;
  text-shadow: 1px 1px 2px #000;
  font-size: 1.5rem;
  background-size: cover;
  background-repeat: no-repeat;
  transition: background-image 1s ease-in-out;
  overflow: hidden;
  background-position: top;
  user-select: none; 
}

@media (max-width: 768px) {
  body {
    background-position: center;
  }
}

body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    opacity: 0;
    transition: opacity 1s ease-in-out;
}

body.fade-in::before {
    opacity: 1;
}

::-moz-selection {
  background-color: rgba(163, 163, 163, 0.25);
  color: #FFFFFF; 
}

::-webkit-scrollbar {
    display: none;
}

/*====================================================================*/

* {
    scrollbar-width: none; 
}

@media (hover: hover) and (pointer: fine) {
    * {
        cursor: var(--cursor-select);
    }
}


input, textarea, select {
    cursor: var(--cursor-input);
}

::selection {
    cursor: var(--cursor-input);
	background-color: rgba(163, 163, 163, 0.25);
    color: #FFFFFF;
}

:root {
    --cursor-button: url('cursors/button.png'), pointer;
    --cursor-select: url('cursors/select.png'), pointer;
    --cursor-input: url('cursors/input.png'), text;
	--cursor-link: url('cursors/link.png'), pointer;
}

/*====================================================================*/

h2 {
  margin: 0 auto;
  width: fit-content;
  text-align: center
}

.animated-text {
  color: #ff0;
  animation: glow 1.5s infinite
}


/*====================================================================*/

.container {
    position: relative;
    width: 62.5vw;
    height: 16.67vh;
    max-width: 62.5vw;
    max-height: 55.56vh;
    padding: 4.17vh;
    background-color: rgba(0, 0, 0, .6);
    border-radius: 1.39vh;
    box-shadow: 0 0 15px rgba(0, 0, 0, .5);
    box-sizing: border-box;
    text-align: center;
    margin-top: -5.85vh;
    z-index: 20;
}

@media (max-width: 768px) {
  .container {
    width: auto;
    height: 13.3vh;
	max-width: 90vw;
    overflow: visible;
  }
}

input {
  width: 100%;
  padding: 15px;
  margin-bottom: 30px;
  border-radius: 5px;
  border: none;
  background-color: #2c2c2c;
  color: #fff;
  font-size: 1.5rem;
  opacity: .55;
}

@media (max-width: 768px) {
  input
     {
    padding: 9px;
    margin-bottom: 33px;
    border-radius: 5px;
  }
}

.input-container {
  position: relative;
  display: flex;
  align-items: center
}

label {
  margin-top: -20px;
  font-size: 1.3em;
  display: block;
  color: #ccc;
  margin-bottom: 10px;
}

@media (max-width: 768px) {
  label {
    font-size: 1em; 
  }
}

.currency-symbol {
  position: absolute;
  right: 2.3vh;
  bottom: 43px;
  pointer-events: none;
  color: rgba(255,255,255,.5);
  font-size: 1.5rem
}

/*====================================================================*/

#result {
  font-size: 2.25rem;
  text-align: center;
  margin-top: 30px;
  color: #fff;
  background: linear-gradient(45deg, #fff, #fff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow: 2px 2px 5px rgba(0, 0, 0, .5);
  font-weight: 700;
  transition: color .3s, transform .3s;
  user-select: none;

  &:hover {
    color: #fff;
    transform: scale(1.05);
  }
}

#purchaseButtons {
    margin-top: 0.5em;
}

.result-container {
    opacity: 0;
    transition: opacity 0.3s ease;
}

.result-container.show {
    opacity: 1;
}

.result-container.hide {
    opacity: 0;
    pointer-events: none;
}

/*====================================================================*/

.erase {
  display: inline-block;
  white-space: nowrap;
  overflow: hidden;
  border-right: 2px solid #fff;
  animation: erase 1s steps(40,end) forwards
}

/*====================================================================*/

.modal {
  display: none;
  position: fixed;
  z-index: 10001;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgba(0,0,0,.8)
}

.modal-content {
  background-color: rgba(44,44,44,.95);
  margin: auto;
  padding: 20px;
  border: 1px solid #888;
  width: 80%;
  max-width: 600px;
  border-radius: 15px;
  font-family: "Courier New",monospace;
  color: #fff;
  margin-top: 3vh;
}

/*====================================================================*/

.country-list {
  list-style: none;
  padding: 0;
  margin: 0
}

.country-items li {
  position: relative;
  padding: 5px;
  transition: transform 0.3s ease, background-color 0.3s ease;
  overflow: hidden;

  &:hover {
    transform: scale(1.2);
    background-color: rgba(163, 163, 163, 0.45);
  }
}

.country-items img {
  width: 32px;
  height: 24px;
  user-select: none;
  pointer-events: none;
  transition: transform 0.3s ease;
}

.country-items {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(1vw, 15.5%));
  gap: 2%; 
  align-items: stretch;
  justify-items: center;
  justify-content: space-evenly;
  margin-top: 2vh; 
}

#countryFlag {
    display: block;
}

/*====================================================================*/

.close {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: 700;
  cursor: var(--cursor-link);

  &:focus,
  &:hover {
    color: #fff;
    text-decoration: none;
  }
}

.notification {
  display: none;
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  padding: 0px 2%;
  background-color: rgba(0, 0, 0, .8);
  color: #fff;
  border-radius: 10px;
  box-shadow: 0 0 15px rgba(0, 0, 0, .5);
  font-size: 1.5rem;
  text-align: center;
  z-index: 10000000;
  animation: fadeIn .5s ease-in-out, fadeOut .5s ease-in-out 1s;

  p {
    line-height: 1.3;
  }
}

/*====================================================================*/

#loadingOverlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #101010;
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    text-align: center;
    background-image: radial-gradient(#141414 1px, transparent 5px);
    background-size: 35px 35px;
    animation: moveDots 120s linear infinite;
    z-index: 9999999;
}

@keyframes moveDots {
    0% {
        background-position: 0 0;
    }
    100% {
        background-position: 100% 100%;
    }
}

#loadingOverlay.hide {
  animation: fadeOutBackground 1s ease forwards
}

.notification-key {
  font-weight: 700;
  color: #fff;
  background-color: rgb(115 117 112 / 59%);
  border-radius: 6px;
  padding: 2px 6px;
  margin: 0 2px;
  box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
  transition: background-color .3s ease, box-shadow .3s ease;
  font-family: 'Courier New', monospace;
  user-select: none;
  cursor: var(--cursor-button);

  &:hover {
	box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
	background-color: rgba(182, 189, 174, 0.8);
  }
}

.toggle-btn {
  display: block;
  margin-top: 17px;
  padding: 10px 20px;
  font-size: 16px;
  border-radius: 5px;
  border: 1px solid #ffffffaa;
  background-color: rgba(0, 0, 0, .45);
  color: #ffffffaa;
  cursor: var(--cursor-button);
  transition: background-color 0.3s;
  overflow: hidden;
  position: relative;
  font-family: 'Courier New', monospace;
  width: 100%;

  &:hover {
    background-color: rgba(0, 0, 0, .6);
  }
}

/*====================================================================*/

#play-button {
  position: fixed;
  top: 0.5%;
  left: 0.5%;
  cursor: var(--cursor-button);
  z-index: 9999
}

#play-icon {
  width: clamp(48px, 2.5vmax, 256px);
  height: clamp(48px, 2.5vmax, 256px);
  opacity: .40;
  cursor: var(--cursor-button);
}

#playing-icon {
  width: clamp(48px, 2.5vmax, 256px);
  height: clamp(48px, 2.5vmax, 256px);
  opacity: .25;
  animation: rotate 2s linear infinite;
  cursor: var(--cursor-button);
}

.volumeBar-in {
    animation: volumeBarIn 0.5s forwards;
}

.volumeBar-out {
    animation: volumeBarOut 0.5s forwards;
}

@keyframes volumeBarIn {
    from { opacity: 0; }
    to { opacity: 0.5; }
}

@keyframes volumeBarOut {
    from { opacity: 0.5; }
    to { opacity: 0; }
}

#volume-bar {
    position: fixed;
    bottom: 5vh;
    right: 1vh;
    width: 0.52vw;
    background: linear-gradient(to top, #fff, #d5d5d5);
    max-height: calc(100vh - 12%);
    background-color: #4caf50;
    opacity: 0.5;
    border-radius: 5px;
    transition: height 0.3s ease, opacity 0.5s ease, border-radius 0.3s ease;
}

@keyframes rotate {
    from {
        transform: rotate(0deg);
    }
    to {
        transform: rotate(360deg);
    }
}

#Settings {
  position: absolute;
  top: 0.5%;
  right: 0.5%;
  cursor: var(--cursor-button);
  width: clamp(48px, 2.5vmax, 256px);
  height: clamp(48px, 2.5vmax, 256px);
  opacity: 0.35;
  z-index: 9999;

  &:hover {
    animation: spin 6s linear infinite;
  }
}


.pulsating {
  animation: pulsate 1s infinite
}

.hidden {
  display: none
}

.purchase-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 6.5vh;
  height: 6.5vh;
  border-radius: 50%;
  background-color: transparent;
  margin: 0 auto;
  z-index: 3000;
  opacity: 0;
  cursor: var(--cursor-link);
  transition: opacity 0.3s ease-in-out, transform 0.3s ease, box-shadow 0.3s ease;
  animation: fadeInModal 0.5s forwards;

  &.show {
    opacity: 1;
  }

  &.hide {
    animation: fadeOut 0.5s forwards;
  }

  &:hover {
    transform: scale(1.3);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  }

  img {
    width: 100%;
    height: 100%;
    transition: transform 0.3s ease;
    position: absolute;
    top: 0;
    left: 0;
    pointer-events: none;
    z-index: 3000;
  }

  &:hover img {
    transform: scale(1.1);
  }
}

#volume-bar-container {
    display: flex;
    justify-content: center;
    margin-top: 10px;
    position: relative;
}

#volume-slider {
  -webkit-appearance: none;
  appearance: none;
  width: 100%;
  height: 10px;
  background: rgba(0, 0, 0, 0.45);
  opacity: 100;
  border-radius: 5px;
  cursor: var(--cursor-select);
  border: 1px solid #ffffffaa;
  outline: none;
  font-family: 'Courier New', monospace;
  margin-bottom: 10px;
  transition: background 0.3s ease, border-color 0.3s ease;

  &:hover {
    background: rgba(0, 0, 0, 0.6);
  }

  &::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 10px;
    height: 25px;
    background: #fff;
    opacity: 50%;
    border-radius: 3px;
    transition: background-color 0.3s ease, opacity 0.3s ease;
    cursor: var(--cursor-link);

    &:hover {
      opacity: 65%;
    }
  }
}

#volume-bar-container span {
    font-size: 16px;
    font-family: 'Courier New', monospace;
    color: #ffffffaa;
    position: absolute;
    top: 45%;
    left: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
}

#countryModal {
  display: none;
  opacity: 0;
  transform: scale(0.9);
  transition: opacity 0.3s ease, transform 0.3s ease;

  &.show {
    display: block;
    animation: fadeInModal 0.3s forwards;
  }
}

/*====================================================================*/

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@keyframes blink-caret {
  from,
  to {
    border-color: transparent
  }
  50% {
    border-color: orange
  }
}

@keyframes pulsate {
  0% {
    opacity: .2
  }
  50% {
    opacity: .6
  }
  100% {
    opacity: .2
  }
}

@keyframes pulse {
  0% {
    transform: scale(1);
    opacity: .2
  }
  50% {
    transform: scale(1.1);
    opacity: .5
  }
  100% {
    transform: scale(1);
    opacity: .2
  }
}

@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateX(-50%) translateY(20px)
  }
  to {
    opacity: 1;
    transform: translateX(-50%) translateY(0)
  }
}

@keyframes fadeOut {
  from {
    opacity: 1;
    transform: translateX(-50%) translateY(0)
  }
  to {
    opacity: 0;
    transform: translateX(-50%) translateY(20px)
  }
}

@keyframes glow {
  0% {
    text-shadow: 0 0 3px rgba(255,255,255,.3)
  }
  50% {
    text-shadow: 0 0 10px rgba(255,255,255,.7)
  }
  100% {
    text-shadow: 0 0 3px rgba(255,255,255,.3)
  }
}

@keyframes fadeOutBackground {
  from {
    opacity: 1
  }
  to {
    opacity: 0
  }
}

@keyframes fadeInBackground {
  from {
    opacity: 0
  }
  to {
    opacity: 1
  }
}

@media (pointer: coarse) {
	.notification-info, #volume-bar-container {
		display: none;
	}
}

@keyframes fadeInModal {
  0% {
    opacity: 0;
    transform: scale(0.9);
  }
  100% {
    opacity: 1;
    transform: scale(1);
  }
}

    </style>
</head>
<body>
<div id="loadingOverlay"></div>
<div id="play-button">
    <img id="play-icon" src="icons/play.png" alt="Play">
    <img id="playing-icon" src="icons/playing.png" alt="Playing" style="display: none;">
</div>

<img id="Settings" src="icons/gear.png" alt="Settings"/>

<div class="container">
    <label for="amount">Your money amount</label>
    <div class="input-container">
        <input type="text" id="amount" placeholder="Amount" autocomplete="off" spellcheck="false">
        <span class="currency-symbol" id="currencySymbol"></span>
    </div>

    <div id="resultContainer" class="result-container hide">
        <div id="result">You can buy<br><span id="copyCount" class="typewriter"></span><br>copies of NieR:Automata</div>
        <div id="purchaseButtons" style="display: flex;"></div>
    </div>
</div>
<div id="notification" class="notification">
    <p>NieR:Automata is not available in your country in Steam. Switched to the USA.</p>
</div>

<div id="countryModal" class="modal">
    <div class="modal-content">
        <span class="close">&times;</span>
        <h2>Region & Settings</h2>
        <ul class="country-list">
            <img id="countryFlag" src="" alt="" style="display: block; margin: 10px auto 0 auto;" />
            <button class="toggle-btn" onclick="toggleAudioFormat()" id="audioToggleBtn"></button>
			<button class="toggle-btn" onclick="toggleVisualizerConfig()" id="visualizerToggleBtn" oncontextmenu="event.preventDefault(); confirm('Do you want to reset the visualizer to the default configuration?') && (VisualizerConfig = VisualizerConfigLinear, updateCanvasFromConfig(), showNotification('Visualizer has been reset to Linear'), updateVisualizerButtonText())"></button>
            <div id="volume-bar-container">
                <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="0.7" />
            </div>

			<div class="country-items">
			<!--- preload ---!> 
			</div>

        </ul>
        <div class="notification-info" style="text-align: right; line-height: 1.3;">
            <p>
				You can switch the UI by pressing <span class="notification-key" data-key="[H]">[H]</span>,<br>
				Pause by <span class="notification-key" data-key="[P]">[P]</span>,<br>
				Play next random by <span class="notification-key" data-key="[N]">[N]</span>,<br>
				Switch the quality of audio by <span class="notification-key" data-key="[Q]">[Q]</span>,<br>
				Loop current song by <span class="notification-key" data-key="[L]">[L]</span>,<br>
				Go to previous song by <span class="notification-key" data-key="[B]">[B]</span> / <span class="notification-key" data-key="[B]">←</span>,<br>
				Go to next song by <span class="notification-key" data-key="[F]">[F]</span> / <span class="notification-key" data-key="[F]">→</span>,<br>
				And change volume by arrow keys.
            </p>
        </div>
    </div>
</div>

    <script>

const protocols = ['http:', 'https:', 'ws:', 'wss:'];

const weburl = protocols.includes(location.protocol)
  ? ''
  : 'https://moshiax.github.io/NierCalculator/';

console.log("Location Protocol:", location.protocol);
console.log("Web URL:", weburl);

class AspectRatio {
    static get value() {
        return window.innerWidth / window.innerHeight;
    }
}
document.documentElement.style.setProperty('--cursor-button', `url('${weburl}cursors/button.png'), pointer`);
document.documentElement.style.setProperty('--cursor-select', `url('${weburl}cursors/select.png'), pointer`);
document.documentElement.style.setProperty('--cursor-input', `url('${weburl}cursors/input.png'), text`);
document.documentElement.style.setProperty('--cursor-link', `url('${weburl}cursors/link.png'), pointer`);

document.querySelectorAll('img, link, a').forEach(element => {
    let href = element.getAttribute('href') || element.getAttribute('src');
    if (href && !/^https?:\/\//.test(href)) {
        let newHref = weburl + href;
        if (element.getAttribute('href')) {
            element.setAttribute('href', newHref);
        } else if (element.getAttribute('src')) {
            element.setAttribute('src', newHref);
        }
    }
});

const containerlist = [
    { code: "US" }, { code: "UA" }, { code: "PL" }, { code: "KZ" }, { code: "KR" }, 
    { code: "BR" }, { code: "MX" }, { code: "IN" }, { code: "UY" }, { code: "KW" }, 
    { code: "ZA" }, { code: "CR" }, { code: "CO" }, { code: "NO" }, { code: "CL" }, 
    { code: "VN" }, { code: "TH" }, { code: "IL" }, { code: "SG" }, { code: "PE" }, 
    { code: "EU" }, { code: "JP" }, { code: "MY" }, { code: "PH" }, { code: "HK" }, 
    { code: "GB" }, { code: "CA" }, { code: "TR" }, { code: "RU" }, { code: "CH", name: "SW" }
];
const countryItemsContainer = document.querySelector('.country-items');

containerlist.forEach(country => {
    const li = document.createElement('li');
    li.setAttribute('data-country-code', country.code);

    const img = document.createElement('img');
    img.src = `${weburl}flags/${country.code.toLowerCase()}.png`;
    img.alt = `${country.code} flag`;

    li.appendChild(img);
    const countryName = country.name || country.code; 
    li.appendChild(document.createTextNode(` ${countryName}`));

    countryItemsContainer.appendChild(li);
});

<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>


!function(t,r){"object"==typeof exports&&"undefined"!=typeof module?module.exports=r():"function"==typeof define&&define.amd?define(r):t.ColorThief=r()}(this,function(){if(!t)var t={map:function(t,r){var n={};return r?t.map(function(t,o){return n.index=o,r.call(n,t)}):t.slice()},naturalOrder:function(t,r){return t<r?-1:t>r?1:0},sum:function(t,r){var n={};return t.reduce(r?function(t,o,e){return n.index=e,t+r.call(n,o)}:function(t,r){return t+r},0)},max:function(r,n){return Math.max.apply(null,n?t.map(r,n):r)}};var r=function(){var r=5,n=8-r,o=1e3;function e(t,n,o){return(t<<2*r)+(n<<r)+o}function i(t){var r=[],n=!1;function o(){r.sort(t),n=!0}return{push:function(t){r.push(t),n=!1},peek:function(t){return n||o(),void 0===t&&(t=r.length-1),r[t]},pop:function(){return n||o(),r.pop()},size:function(){return r.length},map:function(t){return r.map(t)},debug:function(){return n||o(),r}}}function u(t,r,n,o,e,i,u){this.r1=t,this.r2=r,this.g1=n,this.g2=o,this.b1=e,this.b2=i,this.histo=u}function a(){this.vboxes=new i(function(r,n){return t.naturalOrder(r.vbox.count()*r.vbox.volume(),n.vbox.count()*n.vbox.volume())})}function s(r,n){if(n.count()){var o=n.r2-n.r1+1,i=n.g2-n.g1+1,u=t.max([o,i,n.b2-n.b1+1]);if(1==n.count())return[n.copy()];var a,s,h,c,f=0,v=[],l=[];if(u==o)for(a=n.r1;a<=n.r2;a++){for(c=0,s=n.g1;s<=n.g2;s++)for(h=n.b1;h<=n.b2;h++)c+=r[e(a,s,h)]||0;v[a]=f+=c}else if(u==i)for(a=n.g1;a<=n.g2;a++){for(c=0,s=n.r1;s<=n.r2;s++)for(h=n.b1;h<=n.b2;h++)c+=r[e(s,a,h)]||0;v[a]=f+=c}else for(a=n.b1;a<=n.b2;a++){for(c=0,s=n.r1;s<=n.r2;s++)for(h=n.g1;h<=n.g2;h++)c+=r[e(s,h,a)]||0;v[a]=f+=c}return v.forEach(function(t,r){l[r]=f-t}),function(t){var r,o,e,i,u,s=t+"1",h=t+"2",c=0;for(a=n[s];a<=n[h];a++)if(v[a]>f/2){for(e=n.copy(),i=n.copy(),u=(r=a-n[s])<=(o=n[h]-a)?Math.min(n[h]-1,~~(a+o/2)):Math.max(n[s],~~(a-1-r/2));!v[u];)u++;for(c=l[u];!c&&v[u-1];)c=l[--u];return e[h]=u,i[s]=e[h]+1,[e,i]}}(u==o?"r":u==i?"g":"b")}}return u.prototype={volume:function(t){return this._volume&&!t||(this._volume=(this.r2-this.r1+1)*(this.g2-this.g1+1)*(this.b2-this.b1+1)),this._volume},count:function(t){var r=this.histo;if(!this._count_set||t){var n,o,i,u=0;for(n=this.r1;n<=this.r2;n++)for(o=this.g1;o<=this.g2;o++)for(i=this.b1;i<=this.b2;i++)u+=r[e(n,o,i)]||0;this._count=u,this._count_set=!0}return this._count},copy:function(){return new u(this.r1,this.r2,this.g1,this.g2,this.b1,this.b2,this.histo)},avg:function(t){var n=this.histo;if(!this._avg||t){var o,i,u,a,s=0,h=1<<8-r,c=0,f=0,v=0;for(i=this.r1;i<=this.r2;i++)for(u=this.g1;u<=this.g2;u++)for(a=this.b1;a<=this.b2;a++)s+=o=n[e(i,u,a)]||0,c+=o*(i+.5)*h,f+=o*(u+.5)*h,v+=o*(a+.5)*h;this._avg=s?[~~(c/s),~~(f/s),~~(v/s)]:[~~(h*(this.r1+this.r2+1)/2),~~(h*(this.g1+this.g2+1)/2),~~(h*(this.b1+this.b2+1)/2)]}return this._avg},contains:function(t){var r=t[0]>>n;return gval=t[1]>>n,bval=t[2]>>n,r>=this.r1&&r<=this.r2&&gval>=this.g1&&gval<=this.g2&&bval>=this.b1&&bval<=this.b2}},a.prototype={push:function(t){this.vboxes.push({vbox:t,color:t.avg()})},palette:function(){return this.vboxes.map(function(t){return t.color})},size:function(){return this.vboxes.size()},map:function(t){for(var r=this.vboxes,n=0;n<r.size();n++)if(r.peek(n).vbox.contains(t))return r.peek(n).color;return this.nearest(t)},nearest:function(t){for(var r,n,o,e=this.vboxes,i=0;i<e.size();i++)((n=Math.sqrt(Math.pow(t[0]-e.peek(i).color[0],2)+Math.pow(t[1]-e.peek(i).color[1],2)+Math.pow(t[2]-e.peek(i).color[2],2)))<r||void 0===r)&&(r=n,o=e.peek(i).color);return o},forcebw:function(){var r=this.vboxes;r.sort(function(r,n){return t.naturalOrder(t.sum(r.color),t.sum(n.color))});var n=r[0].color;n[0]<5&&n[1]<5&&n[2]<5&&(r[0].color=[0,0,0]);var o=r.length-1,e=r[o].color;e[0]>251&&e[1]>251&&e[2]>251&&(r[o].color=[255,255,255])}},{quantize:function(h,c){if(!h.length||c<2||c>256)return!1;var f=function(t){var o,i=new Array(1<<3*r);return t.forEach(function(t){o=e(t[0]>>n,t[1]>>n,t[2]>>n),i[o]=(i[o]||0)+1}),i}(h);f.forEach(function(){});var v=function(t,r){var o,e,i,a=1e6,s=0,h=1e6,c=0,f=1e6,v=0;return t.forEach(function(t){(o=t[0]>>n)<a?a=o:o>s&&(s=o),(e=t[1]>>n)<h?h=e:e>c&&(c=e),(i=t[2]>>n)<f?f=i:i>v&&(v=i)}),new u(a,s,h,c,f,v,r)}(h,f),l=new i(function(r,n){return t.naturalOrder(r.count(),n.count())});function g(t,r){for(var n,e=t.size(),i=0;i<o;){if(e>=r)return;if(i++>o)return;if((n=t.pop()).count()){var u=s(f,n),a=u[0],h=u[1];if(!a)return;t.push(a),h&&(t.push(h),e++)}else t.push(n),i++}}l.push(v),g(l,.75*c);for(var p=new i(function(r,n){return t.naturalOrder(r.count()*r.volume(),n.count()*n.volume())});l.size();)p.push(l.pop());g(p,c);for(var d=new a;p.size();)d.push(p.pop());return d}}}().quantize,n=function(t){this.canvas=document.createElement("canvas"),this.context=this.canvas.getContext("2d"),this.width=this.canvas.width=t.width,this.height=this.canvas.height=t.height,this.context.drawImage(t,0,0,this.width,this.height)};n.prototype.getImageData=function(){return this.context.getImageData(0,0,this.width,this.height)};var o=function(){};return o.prototype.getColor=function(t,r){return void 0===r&&(r=10),this.getPalette(t,5,r)[0]},o.prototype.getPalette=function(t,o,e){var i=function(t){var r=t.colorCount,n=t.quality;if(void 0!==r&&Number.isInteger(r)){if(1===r)throw new Error("colorCount should be between 2 and 20. To get one color, call getColor() instead of getPalette()");r=Math.max(r,2),r=Math.min(r,20)}else r=10;return void 0===n||Number.isInteger(n)?n=10:n<1&&(n=10),{colorCount:r,quality:n}}({colorCount:o,quality:e}),u=new n(t),a=function(t,r,n){for(var o=t,e=[],i=0,u=void 0,a=void 0,s=void 0,h=void 0,c=void 0;i<r;i+=n)a=o[0+(u=4*i)],s=o[u+1],h=o[u+2],(void 0===(c=o[u+3])||c>=125)&&(a>250&&s>250&&h>250||e.push([a,s,h]));return e}(u.getImageData().data,u.width*u.height,i.quality),s=r(a,i.colorCount);return s?s.palette():null},o.prototype.getColorFromUrl=function(t,r,n){var o=document.createElement("img"),e=this;o.addEventListener("load",function(){var i=e.getPalette(o,5,n);r(i[0],t)}),o.src=t},o.prototype.getImageData=function(t,r){var n=new XMLHttpRequest;n.open("GET",t,!0),n.responseType="arraybuffer",n.onload=function(){if(200==this.status){var t=new Uint8Array(this.response);o=t.length;for(var n=new Array(o),o=0;o<t.length;o++)n[o]=String.fromCharCode(t[o]);var e=n.join(""),i=window.btoa(e);r("data:image/png;base64,"+i)}},n.send()},o.prototype.getColorAsync=function(t,r,n){var o=this;this.getImageData(t,function(t){var e=document.createElement("img");e.addEventListener("load",function(){var t=o.getPalette(e,5,n);r(t[0],this)}),e.src=t})},o});
const getDominantColor = (imageUrl) => new Promise((resolve, reject) => { const img = new Image(); img.crossOrigin = 'Anonymous'; img.src = imageUrl; img.onload = () => resolve(`rgb(${new ColorThief().getColor(img).join(', ')})`); img.onerror = () => reject('Error loading image'); });


function extractDominantColor(canvas) {
    return new Promise((resolve) => {
        const tempImg = new Image();
        tempImg.src = canvas.toDataURL();
        tempImg.onload = () => {
            const colorThief = new ColorThief();
            const dominantColor = colorThief.getColor(tempImg);
            resolve(dominantColor);
        };
        tempImg.onerror = () => {
            console.error('Failed to process canvas image.');
            resolve([0, 0, 0]); 
        };
    });
}
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>

const steamAppId = '524220';

async function getIpAndLocation() {
    return fetch('https://freeipapi.com/api/json/')
        .then(response => response.json())
        .then(data => {
            if (data && data.countryCode) {
                return { country_code: data.countryCode };
            }
            return { country_code: 'US' };
        })
        .catch(error => {
            console.log("Failed to fetch location:", error);
			showNotification('Region Detection blocked by Adblocker. Region set to USA.');
            return { country_code: 'US' };
        });
}

let globalDiscountPercent = null;

async function getGamePrice(countryCode) {
    const url = `https://store.steampowered.com/api/appdetails?appids=${steamAppId}&cc=${countryCode}&l=english&v=1`;
    const proxyUrl = `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`;
    let attempts = 0;
    const maxAttempts = 1;
    const timeoutDuration = 2222;

    while (attempts < maxAttempts) {
        try {
            const controller = new AbortController();
            const signal = controller.signal;
            const timeoutId = setTimeout(() => controller.abort(), timeoutDuration);

            const startTime = performance.now();
            console.log(`Attempt ${attempts + 1}: Fetching URL: ${proxyUrl}`);
            const response = await fetch(proxyUrl, { signal });
            const endTime = performance.now();
            const duration = (endTime - startTime).toFixed(2);

            clearTimeout(timeoutId);

            if (!response.ok) {
                throw new Error(`HTTP Error: ${response.status} - ${response.statusText}`);
            }

            const contents = await response.text();
            const data = JSON.parse(contents);

            if (data[steamAppId]?.data?.price_overview) {
                const discountPercent = data[steamAppId].data.price_overview.discount_percent;
                globalDiscountPercent = discountPercent && discountPercent !== 0 ? discountPercent : null;
                console.log(`Price fetched dynamically in ${duration}ms, discount: ${globalDiscountPercent || "no discount"}`);
            }

            return data;

        } catch (error) {
            attempts++;
            console.error(`Error during fetch attempt ${attempts}:`, error);

            if (attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 500));
            } else {
                console.error('Error fetching prices. CORS proxy possible dead :(');
                return getPriceDataFallback(countryCode);
            }
        }
    }
}

function getPriceDataFallback(countryCode) {
	const priceInfo = priceData.find(item => item.region === countryCode);
	return {
		[steamAppId]: {
			success: !!priceInfo,
			data: priceInfo ? { price_overview: { final: priceInfo.price * 100, currency: priceInfo.currency_code } } : null,
		},
	};
}

const modal = document.getElementById('countryModal');
const settingsButton = document.getElementById('Settings');
const closeButton = document.querySelector('.close');

settingsButton.addEventListener('click', () => modal.classList.add('show'));

closeButton.addEventListener('click', () => modal.classList.remove('show'));

window.addEventListener('click', (event) => {
    if (event.target === modal) {
        modal.classList.remove('show');
    }
});

<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
let loop = false;
let isPlaying = false; 
let playedTracks = [];
let playIndex = 0;
let currentHistoryIndex = -1;
let max_history = 10000;
let audioContext;
let analyser;
let bufferLength;
let dataArray;
let canvas;
let canvasCtx;
let audioFormatPreference = /mobile/i.test(navigator.userAgent) ? 1 : 0;
let audioVolume = loadVolumeFromLocalStorage();
let currentTrackInfo = {};
audioVolume = audioVolume !== null ? audioVolume : 0.5;
console.log(audioVolume !== 0.5 
    ? `Volume loaded from localStorage: ${audioVolume}` 
    : `Default volume set: ${audioVolume}`);

let audio = null;
let hideTimeout;

document.getElementById('volume-slider').value = audioVolume;

function saveAudioFormatPreferenceToLocalStorage() {
    localStorage.setItem('audioFormatPreference', audioFormatPreference);
}

function loadAudioFormatPreferenceFromLocalStorage() {
    const storedPreference = localStorage.getItem('audioFormatPreference');

    if (storedPreference !== null) {
        audioFormatPreference = parseInt(storedPreference);

        let format;
        if (audioFormatPreference === 1) {
            format = 'mp3';
        } else if (audioFormatPreference === 2) {
            format = 'flac';
        } else {
            format = 'auto';
        }

        console.log(`Loaded: ${format}`);
    }
}

loadAudioFormatPreferenceFromLocalStorage();

updateButtonText();

async function fadeOutAudio(audio, duration = 1000) {
    if (!audio) return;
    let volume = audio.volume;
    const step = volume / (duration / 50);

    return new Promise(resolve => {
        const fadeOutInterval = setInterval(() => {
            if (volume > 0) {
                volume = Math.max(0, volume - step);
                audio.volume = volume;
            } else {
                clearInterval(fadeOutInterval);
                audio.pause();
                resolve();
            }
        }, 50);
    });
}

function fadeInAudio(audio, duration = 1000) {
    let volume = 0;
    const targetVolume = audioVolume; 
    const step = targetVolume / (duration / 50);
    audio.volume = 0;
    audio.play().catch(error => console.error('Error:', error));

    const fadeInInterval = setInterval(() => {
        if (volume < targetVolume) {
            volume = Math.min(targetVolume, volume + step);
            audio.volume = volume;
        } else {
            clearInterval(fadeInInterval);
        }
    }, 50);
}

function smoothSetSliderValue(slider, targetValue) {
    const currentValue = parseFloat(slider.value);
    const step = (targetValue - currentValue) / 15; 

    let frame = 0;
    function animate() {
        if (frame < 15) {
            slider.value = (currentValue + step * frame).toFixed(2);
            frame++;
            requestAnimationFrame(animate);
        } else {
            slider.value = targetValue.toFixed(2);
        }
    }

    animate();
}

document.addEventListener('keydown', (event) => {
    const isTyping = document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA';
    if (isTyping) return; 
    if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
        audioVolume = event.key === 'ArrowUp'
            ? Math.min(audioVolume + 0.05, 1)
            : Math.max(audioVolume - 0.05, 0);

        if (audio) {
            audio.volume = audioVolume;
        }

        saveVolumeToLocalStorage(audioVolume);
        showVolumeBar(audioVolume);
        smoothSetSliderValue(document.getElementById('volume-slider'), audioVolume);
    }
});

document.getElementById('volume-slider').addEventListener('input', (event) => {
    audioVolume = parseFloat(event.target.value);
    if (audio) {
        audio.volume = audioVolume;
    }
    saveVolumeToLocalStorage(audioVolume);
    showVolumeBar(audioVolume);
});

function saveVolumeToLocalStorage(volume) {
    const roundedVolume = parseFloat(volume.toFixed(2));
    localStorage.setItem('audioVolume', roundedVolume);
}
function loadVolumeFromLocalStorage() {
    const storedVolume = localStorage.getItem('audioVolume');
    return storedVolume !== null ? parseFloat(parseFloat(storedVolume).toFixed(2)) : null;
}

const volumeText = document.createElement('span');
volumeText.textContent = 'Volume'; 
document.getElementById('volume-bar-container').appendChild(volumeText);

function showVolumeBar(volume) {
    let volumeBar = document.getElementById('volume-bar');
    if (!volumeBar) {
        volumeBar = document.createElement('div');
        volumeBar.id = 'volume-bar';
        document.body.appendChild(volumeBar);
    }

    volumeBar.style.height = `${volume * 100}%`;
    volumeBar.classList.add('volumeBar-in');
    volumeBar.style.visibility = 'visible';
    clearTimeout(hideTimeout);

    hideTimeout = setTimeout(() => {
        volumeBar.classList.add('volumeBar-out');
        setTimeout(() => {
            volumeBar.style.visibility = 'hidden';
            volumeBar.classList.remove('volumeBar-out');
        }, 500);
    }, 1000);
}

async function playMusic(trackName, isRandomPlay = false, skipHistory = false) {
    if (!skipHistory) {
        if (currentHistoryIndex < playedTracks.length - 1) {
            playedTracks = playedTracks.slice(0, currentHistoryIndex + 1);
        }

        playedTracks.push({ index: playIndex++, trackName });
        currentHistoryIndex = playedTracks.length - 1;
        if (playedTracks.length > max_history) {
            playedTracks.shift();
            currentHistoryIndex--;
        }
    }
    let format;

    if (audioFormatPreference === 1) {
        format = '.mp3';
        console.log("Chosen: mp3");
    } else if (audioFormatPreference === 2) {
        format = '.flac';
        console.log("Chosen: flac");
    } else {
        format = isFlacSupported() ? '.flac' : '.mp3';
        console.log(`Auto: ${format === '.flac' ? 'flac' : 'mp3'}`);
    }

    const audioSrc = weburl + phrases[trackName].audio.src + format;

    if (isPlaying) {
        await fadeOutAudio(document.getElementById('current-audio'));
        stopMusic();
    }

    audio = new Audio(audioSrc);
    audio.crossOrigin = 'anonymous';
    audio.id = 'current-audio';
    audio.volume = audioVolume;
    const getBackgroundSrc = (bgObj) => Object.keys(bgObj)[0];

    const backgroundSrc =
        (Math.abs(AspectRatio.value - 9 / 16) < Math.abs(AspectRatio.value - 16 / 9) &&
            getBackgroundSrc(phrases[trackName].backgroundAndroid) !== "backgrounds/!!!!!!!!!.jpg")
            ? getBackgroundSrc(phrases[trackName].backgroundAndroid)
            : getBackgroundSrc(phrases[trackName].background);

    const chosenBackground = backgroundSrc === getBackgroundSrc(phrases[trackName].background)
        ? phrases[trackName].background
        : phrases[trackName].backgroundAndroid;

    const artAuthor = chosenBackground[backgroundSrc]?.author;
    const artLink = chosenBackground[backgroundSrc]?.link;

    if (!audioContext) {
        createVisualizer();
    }

    const source = audioContext.createMediaElementSource(audio);
    source.connect(analyser);
    analyser.connect(audioContext.destination);

    await changeBackground(backgroundSrc);
    drawVisualizer();

    if ('mediaSession' in navigator) {
        navigator.mediaSession.metadata = new MediaMetadata({
            title: phrases[trackName].audio.title,
            artist: phrases[trackName].audio.artist,
        });

        navigator.mediaSession.setActionHandler('previoustrack', () => handleKeyAction('[B]'));
		navigator.mediaSession.setActionHandler('play', () => handleKeyAction('[P]'));
		navigator.mediaSession.setActionHandler('pause', () => handleKeyAction('[P]'));
        navigator.mediaSession.setActionHandler('nexttrack', playRandomMusic);
    }

	const img = new Image();
	const artworkSrcRaw = getBackgroundSrc(phrases[trackName].background);
	const artworkSrc = weburl + artworkSrcRaw;
	img.crossOrigin = 'anonymous';

	if ((artworkSrcRaw.match(/!/g) || []).length <= 3) {
		img.src = artworkSrc;
	}

    audio.onended = () => {
        isPlaying = false;
        currentTrackInfo.currentTrackAudioSrc = '';
        if (canvas) document.body.removeChild(canvas);
        if (audioContext) {
            audioContext.close();
            audioContext = null;
        }
        updatePlayIcon();

        if (loop) {
            playMusic(trackName, isRandomPlay);
        } else if (isRandomPlay) {
            playRandomMusic();
        } else {
            toggleVisibility();
        }
    };

    isPlaying = true;

    const container = document.querySelector('.container');
    const countryFlag = document.getElementById('countryFlag');
    const isContainerVisible = container && getComputedStyle(container).display !== 'none' && getComputedStyle(container).visibility !== 'hidden';
    const isCountryFlagVisible = countryFlag && getComputedStyle(countryFlag).display !== 'none' && getComputedStyle(countryFlag).visibility !== 'hidden';

    if (isContainerVisible && isCountryFlagVisible) {
        toggleVisibility();
    }

    const isMobile = window.matchMedia('(pointer: coarse)').matches;

    document.body.appendChild(audio);
    fadeInAudio(audio);
    updatePlayIcon();

	currentTrackInfo = {
		track: phrases[trackName].audio.title,
		artist: phrases[trackName].audio.artist,
		background: backgroundSrc,
		artAuthor: artAuthor || 'Unknown',
        artLink: artLink || '',
		currentTrackAudioSrc: audioSrc,
		currentTrackKeywords: trackName
	};

    console.log(currentTrackInfo);

	if (!isMobile) {
		let message = `${phrases[trackName].audio.title}\n${phrases[trackName].audio.artist}`;

		if (artAuthor && artAuthor !== 'Square Enix') {
			message += `<br>Art: <span class="notification-key" data-key="LINK=${artLink}">${artAuthor}</span>`;
		}

		showNotification(message);
	}

    img.onload = () => {
        if ('mediaSession' in navigator) {
            navigator.mediaSession.metadata.artwork = [
                {
                    src: artworkSrc,
                    sizes: `${img.width}x${img.height}`,
                    type: 'image/jpeg'
                }
            ];
        }
    };
	console.log(navigator.mediaSession);

    const amountInput = document.getElementById('amount');
	amountInput.value = '';
	lastPhrase = '';
}

function isFlacSupported() {
    const audio = new Audio();
    return audio.canPlayType('audio/flac;') !== '';
}

function playRandomMusic() {
    const trackNames = Object.keys(phrases);
    const randomTrack = trackNames[Math.floor(Math.random() * trackNames.length)];
    playMusic(randomTrack, true); 
}

function stopMusic() {
    const currentAudio = document.getElementById('current-audio');
    if (currentAudio) {
        currentAudio.pause();
        currentAudio.currentTime = 0; 
        currentAudio.remove();
    }

    if (audioContext) {
        audioContext.close();
        audioContext = null;
    }
    if (canvas) {
        document.body.removeChild(canvas);
        canvas = null;
    }

    if ('mediaSession' in navigator) {
        navigator.mediaSession.metadata = null;
        navigator.mediaSession.playbackState = 'none';
    }

    isPlaying = false;
    updatePlayIcon();
    currentTrackInfo.currentTrackAudioSrc = '';
}

function updatePlayIcon() {
    const playIcon = document.getElementById('play-icon');
    const playingIcon = document.getElementById('playing-icon');

    if (isPlaying) {
        playIcon.style.display = 'none';
        playingIcon.style.display = 'block';
    } else {
        playIcon.style.display = 'block';
        playingIcon.style.display = 'none';
    }
}

document.getElementById('play-button').addEventListener('click', async () => {
    const audio = document.getElementById('current-audio');

    if (isPlaying) {
        await fadeOutAudio(audio);
        stopMusic();
        toggleVisibility();
    } else {
        playRandomMusic();
    }
});

<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>

let gap;

VisualizerConfigLinear = { // This is an example, to apply - modify VisualizerConfig
    dynamic: {
        rendererType: 'linear',                        // Visualization type: 'linear' or 'circle'
        visualizerColor: 'rgba(240, 235, 220, 0.95)',
        barWidthMultiplier: 2.5,                       // Multiplier for bar width in linear mode
        barLengthDivider: 2,                           // Divides bar length
		gap: undefined  // Gap between bars in linear mode; undefined means autogap (let gap) from updateOrientation()
    },
    static: { // Supports css, needs to be updated manually by  updateCanvasFromConfig();
        fftSize: 512,                                  // FFT size, controls spectrum detail
        canvas: {
            width: '100%',                             // CSS width of canvas element (can be %, px, etc.)
            height: '14%',                             // CSS height of canvas element
            renderWidth: 300,                          // Rendering canvas width
            renderHeight: 150,                         // Rendering canvas height
            position: 'fixed',
            bottom: '0',
            left: '0',
            pointerEvents: 'none',
            zIndex: '0',
        }
    }
};

VisualizerConfigCircle = {
    dynamic: {
        rendererType: 'circle',
        visualizerColor: 'rgba(240, 235, 220, 0.95)',
        lineWidth: 2,                                  // Line thickness in circle mode
        radiusRatio: 0.25,                             // Circle radius ratio relative to canvas size in circle mode
        barLengthDivider: 2,
        rotationSpeed: 0
    },
    static: {
        fftSize: 512,
        canvas: {
            width: '100%',
            height: '100%',
            renderWidth: '100%',
            renderHeight: '100%',
            position: 'fixed',
            bottom: '0',
            left: '0',
            pointerEvents: 'none',
            zIndex: '0',
        }
    }
};

function saveVisualizerConfigToLocalStorage() {
    localStorage.setItem('VisualizerConfig', JSON.stringify(VisualizerConfig));
}

function loadVisualizerConfigFromLocalStorage() {
    const storedPreference = localStorage.getItem('VisualizerConfig');

    if (storedPreference !== null) {
        VisualizerConfig = JSON.parse(storedPreference);
        console.log('Loaded visualizer config:', VisualizerConfig);
    } else {
        VisualizerConfig = VisualizerConfigLinear;
        console.log('Loaded default visualizer config:', VisualizerConfig);
    }
}

loadVisualizerConfigFromLocalStorage();

function updateCanvasFromConfig(cfg = VisualizerConfig) {
	saveVisualizerConfigToLocalStorage()
    if (!canvas) return;

    for (const [k, v] of Object.entries(cfg.static.canvas)) {
        if (k in canvas.style) {
            canvas.style[k] = v ?? '';
        }
    }

    if (typeof cfg.static.canvas.renderWidth === 'string' && cfg.static.canvas.renderWidth.includes('%')) {
        canvas.width = (innerWidth * parseFloat(cfg.static.canvas.renderWidth) / 100);
    } else {
        canvas.width = parseInt(cfg.static.canvas.renderWidth, 10);
    }

    if (typeof cfg.static.canvas.renderHeight === 'string' && cfg.static.canvas.renderHeight.includes('%')) {
        canvas.height = (innerHeight * parseFloat(cfg.static.canvas.renderHeight) / 100);
    } else {
        canvas.height = parseInt(cfg.static.canvas.renderHeight, 10);
    }

    if (analyser) {
        analyser.fftSize = cfg.static.fftSize;
        bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);
    }
}

function createVisualizer() {
    if (!audioContext) {
        audioContext = new (AudioContext || webkitAudioContext)();

        canvas = document.createElement('canvas');
        canvas.style.position = VisualizerConfig.static.canvas.position;
        canvas.style.bottom = VisualizerConfig.static.canvas.bottom;
        canvas.style.left = VisualizerConfig.static.canvas.left;
        canvas.style.width = VisualizerConfig.static.canvas.width;
        canvas.style.height = VisualizerConfig.static.canvas.height;
        canvas.style.pointerEvents = VisualizerConfig.static.canvas.pointerEvents;
        canvas.style.zIndex = VisualizerConfig.static.canvas.zIndex;

        document.body.appendChild(canvas);

        canvasCtx = canvas.getContext('2d');

        analyser = audioContext.createAnalyser();
        analyser.fftSize = VisualizerConfig.static.fftSize;
        bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);
        updateCanvasFromConfig(VisualizerConfig);
    }
}

function drawVisualizer() {
    if (!canvas || !canvasCtx || !analyser) return;

    requestAnimationFrame(drawVisualizer);

    analyser.getByteFrequencyData(dataArray);
    canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

    if (VisualizerConfig.dynamic.rendererType === 'linear') {
        const barWidth = (canvas.width / bufferLength) * VisualizerConfig.dynamic.barWidthMultiplier;
        const spacing = VisualizerConfig.dynamic.gap !== undefined ? VisualizerConfig.dynamic.gap : gap;

        let x = 0;
        canvasCtx.fillStyle = VisualizerConfig.dynamic.visualizerColor;

        for (let i = 0; i < bufferLength; i++) {
            const barHeight = dataArray[i] / VisualizerConfig.dynamic.barLengthDivider;
            canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
            x += barWidth + spacing;
        }

    } else if (VisualizerConfig.dynamic.rendererType === 'circle') {
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = Math.min(canvas.width, canvas.height) * VisualizerConfig.dynamic.radiusRatio;
        const angleStep = (2 * Math.PI) / bufferLength;

        const rotationSpeed = VisualizerConfig.dynamic.rotationSpeed;
        const rotation = (rotationSpeed && rotationSpeed > 0)
            ? (performance.now() * rotationSpeed) % (2 * Math.PI)
            : 0;

        canvasCtx.strokeStyle = VisualizerConfig.dynamic.visualizerColor;
        canvasCtx.lineWidth = VisualizerConfig.dynamic.lineWidth;

        for (let i = 0; i < bufferLength; i++) {
            const barHeight = dataArray[i] / VisualizerConfig.dynamic.barLengthDivider;
            const angle = i * angleStep + rotation;

            const x1 = centerX + Math.cos(angle) * radius;
            const y1 = centerY + Math.sin(angle) * radius;
            const x2 = centerX + Math.cos(angle) * (radius + barHeight);
            const y2 = centerY + Math.sin(angle) * (radius + barHeight);

            canvasCtx.beginPath();
            canvasCtx.moveTo(x1, y1);
            canvasCtx.lineTo(x2, y2);
            canvasCtx.stroke();
        }
    }
}

function updateVisualizerButtonText() {
    const button = document.getElementById('visualizerToggleBtn');
    let newText;

    if (JSON.stringify(VisualizerConfig) === JSON.stringify(VisualizerConfigLinear)) {
        newText = 'Linear Visualizer';
    } else if (JSON.stringify(VisualizerConfig) === JSON.stringify(VisualizerConfigCircle)) {
        newText = 'Circle Visualizer';
    } else {
        newText = 'Custom Visualizer';
    }

    button.classList.add('fade-out');
    setTimeout(() => {
        button.textContent = newText;
        button.classList.remove('fade-out');
    }, 500);
}

function toggleVisualizerConfig() {
    if (JSON.stringify(VisualizerConfig) === JSON.stringify(VisualizerConfigLinear)) {
        VisualizerConfig = VisualizerConfigCircle;
        updateCanvasFromConfig();
        showNotification('Visualizer changed to Circle');
    } else if (JSON.stringify(VisualizerConfig) === JSON.stringify(VisualizerConfigCircle)) {
        VisualizerConfig = VisualizerConfigLinear;
        updateCanvasFromConfig();
        showNotification('Visualizer changed to Linear');
    } else {
        const configString = `VisualizerConfig = ${JSON.stringify(VisualizerConfig, null, 4)};`;
        navigator.clipboard.writeText(configString)
            .then(() => showNotification('Custom visualizer config copied to clipboard'))
            .catch(() => showNotification('Failed to copy custom visualizer config'));
    }

    updateVisualizerButtonText();
}

updateVisualizerButtonText();

<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>

const getCurrencySymbol = (currencyCode) => ({ "USD": "$", "EUR": "€", "GBP": "£", "JPY": "¥", "RUB": "₽", "UAH": "₴", "BRL": "R$", "CAD": "C$", "AUD": "A$", "CHF": "Fr", "CNY": "¥", "KRW": "₩", "INR": "₹", "MXN": "Mex$", "PLN": "zł", "ZAR": "R", "TRY": "₺", "AED": "د.إ", "THB": "฿", "TWD": "NT$", "SAR": "ر.س", "QAR": "ر.ق", "KWD": "د.ك", "KZT": "₸", "MYR": "RM", "IDR": "Rp", "ILS": "₪", "COP": "$", "CRC": "₡", "PEN": "S/", "PHP": "₱", "VND": "₫", "CLP": "$", "GEL": "₾", "HRK": "kn", "HUF": "Ft", "LKR": "Rs", "MDL": "L", "NOK": "kr", "RON": "lei", "SEK": "kr", "UGX": "USh", "MNT": "₮", "TZS": "TSh", "NAD": "$", "ZWL": "$", "BAM": "KM", "GHS": "₵", "BND": "$", "SBD": "$", "MOP": "MOP$", "PGK": "K" })[currencyCode] || currencyCode;
let priceData; 
let salenotifications = 0;
let lastPhrase = '';

const amountInput = document.getElementById('amount');

fetch(weburl + 'price_standalone.json')
    .then(response => response.ok ? response.json() : Promise.reject('Error: ' + response.statusText))
    .then(data => priceData = data)
    .catch(console.error);

let purchaseButtonVisible = false;
let lastConvertedAmount = null;

amountInput.addEventListener('input', () => {
  const inputText = amountInput.value.trim().toLowerCase();

  for (const phraseKey in phrases) {
	const triggers = phraseKey.split('|').map(p => p.trim());
	for (const trigger of triggers) {
	  if (containsAllWords(inputText, trigger)) {
		if (phrases[phraseKey] && phraseKey !== lastPhrase) {
		  lastPhrase = phraseKey;
		  console.log(`Playing music for phrase: ${phraseKey}`);
		  playMusic(phraseKey);
		  return;
		}
	  }
	}
  }
});
async function updatePrice(countryCode) {
    try {
        const priceData = await getGamePrice(countryCode);

        const currencySymbol = document.getElementById('currencySymbol');
        const countryFlag = document.getElementById('countryFlag');

        const overview = priceData[steamAppId]?.data?.price_overview;
        if (!overview) {
            throw new Error('Price information not available');
        }

        const price = overview.final / 100;
        let currencyCode = overview.currency;
        if (countryFlag.getAttribute('data-country-code') === 'EU') {
            currencyCode = 'EUR';
        }
        currencySymbol.textContent = getCurrencySymbol(currencyCode);

        const updatePriceDisplay = () => {
            setTimeout(() => {
                const raw = amountInput.value;
                const num = parseFloat(raw.replace(/\D/g, ''));

                const convertedAmount = (!isNaN(num) && price > 0)
                    ? Math.floor(num / price)
                    : 0;

                updatePurchaseUI(convertedAmount);
            }, 100);
        };

        amountInput.removeEventListener('input', updatePriceDisplay);
        amountInput.addEventListener('input', updatePriceDisplay);

        updatePriceDisplay();

        if (globalDiscountPercent && globalDiscountPercent !== 0 && salenotifications >= 1) {
            showNotification(`NieR:Automata is on sale in ${countryCode}. Discount is ${globalDiscountPercent}%`);
        }
        salenotifications++;

    } catch (error) {
        console.error('Error:', error);
        showNotification('NieR:Automata is not available in your country. Switched to the USA.');
        document.getElementById('countryFlag').src = 'flags/us.png';
        await updatePrice('US');
    }
}

const purchaseOptions = [
    {
        id: 'xboxButton',
        icon: `${weburl}icons/xbox.png`,
        alt: 'Xbox',
        url: 'https://www.xbox.com/games/store/nier-automata-become-as-gods-edition/bppzvt8bz15n'
    },
    {
        id: 'steamButton',
        icon: `${weburl}icons/steam.png`,
        alt: 'Steam',
        url: 'https://store.steampowered.com/app/524220/NieRAutomata/'
    },
    {
        id: 'walmartButton',
        icon: `${weburl}icons/walmart.png`,
        alt: 'Walmart',
        url: 'https://www.walmart.com/ip/Nier-Automata-Game-of-The-Yorha-Edition-Square-Enix-PlayStation-4-662248922225/339689531'
    }
];

function updatePurchaseUI(convertedAmount) {
    const container = document.getElementById('resultContainer');
    const priceEl = document.getElementById('result');
    const buttons = document.getElementById('purchaseButtons');
    const isVisible = container.classList.contains('show');

    if (convertedAmount >= 1) {
        if (isVisible && convertedAmount === lastConvertedAmount) {
            return;
        }

        lastConvertedAmount = convertedAmount;

        const textHTML = convertedAmount.toString().includes('e')
            ? `You can buy<br><span id="animated-text" class="animated-text">a lot but not enough</span><br>copies of NieR:Automata`
            : `You can buy<br><span id="copyCount" class="typewriter">${convertedAmount}</span><br>copies of NieR:Automata`;

        priceEl.innerHTML = textHTML;

        if (!buttons.hasChildNodes()) {
            purchaseOptions.forEach(({ id, url, icon }) => {
                const btn = document.createElement('div');
                btn.className = 'purchase-button';
                btn.id = id;

                const img = document.createElement('img');
                img.src = icon;
                img.alt = id;
                btn.appendChild(img);

                btn.onclick = () => window.open(url, '_blank');

                buttons.appendChild(btn);

                getDominantColor(icon)
                    .then(color => {
                        btn.style.filter = `drop-shadow(0 0 10px ${color}) brightness(1.2)`;
                    })
                    .catch(() => {});
            });
        }

        if (!isVisible) {
            container.classList.remove('hide');
            container.classList.add('show');
        }

        purchaseButtonVisible = true;

    } else {
        if (!isVisible) return;

        container.classList.remove('show');
        container.classList.add('hide');
        purchaseButtonVisible = false;
        lastConvertedAmount = null;
    }
}

document.querySelectorAll('.country-list li').forEach(item => {
    item.addEventListener('click', async () => {
        const selectedCountryCode = item.dataset.countryCode;
        const flagSrc = item.querySelector('img').src;
        const countryFlag = document.getElementById('countryFlag');
        countryFlag.src = flagSrc;
        countryFlag.dataset.countryCode = selectedCountryCode;

        document.getElementById('countryModal').classList.remove('show');
        localStorage.setItem('selectedCountryCode', selectedCountryCode);
        
        await updatePrice(selectedCountryCode);
    });
});

function containsAllWords(inputText, phraseKey) {
    const words = phraseKey.split(' ');
    return words.every(word => inputText.includes(word));
}

async function changeBackground(imageUrl) {
    if ((imageUrl.match(/!/g) || []).length > 4) {
        return;
    }
    const body = document.body;
	imageUrl = weburl + imageUrl;

    const currentBackground = body.style.backgroundImage.replace(/url\((['"])?(.*?)\1\)/gi, '$2');

    if (currentBackground === imageUrl) return;

    body.classList.add('fade-in');

    try {
        await loadImage(imageUrl);

        const img = new Image();
		img.crossOrigin = 'anonymous'
        img.src = imageUrl;

        img.onload = async () => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = 10;
            ctx.drawImage(img, 0, img.height - 10, img.width, 10, 0, 0, img.width, 10);

            const dominantColor = await extractDominantColor(canvas);

            body.style.backgroundColor = `rgb(${dominantColor.join(',')})`;
            setTimeout(() => {
                body.style.backgroundImage = `url(${imageUrl})`;
            }, 200);

            setTimeout(() => body.classList.remove('fade-in'), 1000);
        };
    } catch (error) {
        console.error('Error:', error);
    }
}

function loadImage(imageUrl) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.src = imageUrl;
        img.onload = resolve;
        img.onerror = reject;
    });
}

function updateBackgroundBasedOnOrientation() {
	if (typeof currentTrackInfo.currentTrackKeywords === "undefined") return;
    const body = document.body;
    const rawBackground = body.style.backgroundImage;
    const currentBackground = rawBackground
        .replace(/url\((['"])?(.*?)\1\)/gi, '$2')
        .replace(/^.*?backgrounds\//, 'backgrounds/')
        .replace(/^.*?bonus\//, 'bonus/');

    const track = phrases[currentTrackInfo.currentTrackKeywords];
    const bg = Object.keys(track.background || {})[0] || '';
    const bgAndroid = Object.keys(track.backgroundAndroid || {})[0] || '';

    const targetBackground = orientation === 'portrait' && bgAndroid !== 'backgrounds/!!!!!!!!!.jpg'
        ? bgAndroid
        : bg;

	if (currentBackground !== targetBackground && targetBackground !== 'backgrounds/!!!!!!!!!.jpg') {
		changeBackground(targetBackground);
	}
}

let orientation;

function updateOrientation() {
    orientation = innerWidth / innerHeight > 1 ? 'landscape' : 'portrait';

    if (orientation === 'portrait' && (gap === 2 || gap === undefined)) {
        gap = 4;
    } else if (orientation === 'landscape' && (gap === 4 || gap === undefined)) {
        gap = 2;
    }
	updateCanvasFromConfig(cfg = VisualizerConfig) 
}

function onResize() {
    updateOrientation();
    updateBackgroundBasedOnOrientation();
}

window.addEventListener('resize', onResize);
document.addEventListener('DOMContentLoaded', () => {
    updateOrientation();
});

<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>

document.addEventListener('click', function(event) {
    const target = event.target;
    if (target.classList.contains('notification-key')) {
        const key = target.getAttribute('data-key');
        handleKeyAction(key);
    }
});

let notificationShown = 0;

function showNotification(message) {
    if (notificationShown === 1) {
        setTimeout(() => {
            showNotification(message);
        }, 100);
        return;
    }

    notificationShown = 1;

    let formattedMessage = message.replace(/\n/g, '<br>').replace(/\[(H|P|N|Q)\]/g, match => 
        `<span class="notification-key" data-key="${match}">${match}</span>`
    );

    const discountPercentMatch = message.match(/Discount percent is (\d+)%/);
    if (discountPercentMatch) {
        const discountPercent = discountPercentMatch[1];
        formattedMessage = formattedMessage.replace(
            `Discount percent is ${discountPercent}%`, 
            `<span class="discount-highlight">Discount percent is <b>${discountPercent}%</b></span>`
        );
    }

    const notification = document.getElementById('notification');
    notification.querySelector('p').innerHTML = formattedMessage;
    notification.style.display = 'block';
    notification.style.animation = 'fadeIn 0.5s ease-in-out';

    const notificationObj = {
        message: formattedMessage,
        timestamp: new Date().toISOString()
    };
    console.log('Notification:', notificationObj);

    setTimeout(() => {
        notification.style.animation = 'fadeOut 0.5s ease-in-out';
        setTimeout(() => {
            notification.style.display = 'none';
            notificationShown = 0;
        }, 500);
    }, 2300);
}

function toggleAudioFormat() {
	if (audioFormatPreference === 0 || audioFormatPreference === 2) {
		audioFormatPreference = 1;
		showNotification('Format changed to mp3 - 320 kbps');
	} else {
		audioFormatPreference = 2;
		showNotification('Format changed to flac - up to 1000 kbps');
	}
	updateButtonText(); 
	saveAudioFormatPreferenceToLocalStorage(); 
}

function updateButtonText() {
    const button = document.getElementById('audioToggleBtn');
    let newText;

    if (audioFormatPreference === 0) {
        newText = 'AUDIO QUALITY - AUTO';
    } else if (audioFormatPreference === 1) {
        newText = 'AUDIO QUALITY - MP3 (320 KBPS)';
    } else {
        newText = 'AUDIO QUALITY - FLAC (UP TO 1000 KBPS)';
    }

    button.classList.add('fade-out');
    setTimeout(() => {
        button.textContent = newText;
        button.classList.remove('fade-out');
    }, 500);
}

function handleKeyAction(key) {
    const actions = {
        '[H]': toggleVisibility,
        '[P]': async () => {
            const currentAudio = document.getElementById('current-audio');
            if (currentAudio) {
                if (currentAudio.paused) {
                    fadeInAudio(currentAudio);
                    isPlaying = true;
                } else {
                    await fadeOutAudio(currentAudio);
                    currentAudio.pause();
                    isPlaying = false;
                }
                updatePlayIcon();
            }
        },
        '[N]': () => {
            if (isPlaying) {
                playRandomMusic();
            }
        },
        '[Q]': toggleAudioFormat,
        '[L]': () => {
            loop = !loop;
            showNotification(`Current song now will ${loop ? '' : 'not '}be looped infinitely`);
        },
        '[B]': async () => {
            if (currentHistoryIndex > 0) {
                currentHistoryIndex--;
                const prevTrack = playedTracks[currentHistoryIndex];
                await playMusic(prevTrack.trackName, false, true);
            } else {
          //      showNotification('No previous song');
            }
        },
        '[F]': async () => {
            if (currentHistoryIndex < playedTracks.length - 1) {
                currentHistoryIndex++;
                const nextTrack = playedTracks[currentHistoryIndex];
                await playMusic(nextTrack.trackName, false, true);
            } else {
           //     showNotification('No next song');
            }
        },
        'LINK': (link) => {
            if (link) {
                window.open(link, '_blank');
            }
        }
    };

    const match = key.match(/^LINK=(.+)$/);
    if (match) {
        const link = match[1];
        (actions['LINK'] || (() => console.log(`Unknown LINK key`)))(link);
    } else {
        (actions[key] || (() => console.log(`Unknown key: ${key}`)))();
    }
}

document.addEventListener('keydown', async (event) => {
    const isTyping = document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA';
    if (isTyping) return;

    const keyMap = {
        'KeyH': '[H]', // Hide ui
        'KeyP': '[P]', // Pause
        'KeyN': '[N]', // Next random song
        'KeyQ': '[Q]', // Quality
        'KeyL': '[L]', // Loop
        'ArrowLeft': '[B]', // Previous song from history
        'KeyB': '[B]', // Previous song from history
        'ArrowRight': '[F]', // Next song from history
        'KeyF': '[F]' // Next song from history
    };

    if (keyMap[event.code]) {
        event.preventDefault();
        await handleKeyAction(keyMap[event.code]);
    }
});

let isVisible = false;

function toggleVisibility() {
    console.log('togglecalled')
    const elementsToToggle = [
        document.querySelector('.container'),
    ];

    isVisible = !isVisible;

    elementsToToggle.forEach(element => {
        if (isVisible) {
            element.style.display = '';
            element.style.transition = 'opacity 0.5s';
            element.style.opacity = 0;
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    element.style.opacity = 1;
                });
            });
        } else {
            element.style.transition = 'opacity 0.5s';
            element.style.opacity = 0;

            element.addEventListener('transitionend', function handler() {
                if (!isVisible) {
                    element.style.display = 'none';
                }
                element.removeEventListener('transitionend', handler);
            });
        }
    });
}

<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
async function setBackground() {
    const special = {
        'events': [
            { 
                dates: ['01-7', '12-25'], 
                message: 'Merry Christmas!', 
                backgrounds: ['bonus/winter.jpg', 'backgrounds/background03.jpg'] 
            },
            { 
                dates: ['1-1', '12-31'], 
                message: (now) => `Happy New ${now.getMonth() === 0 && now.getDate() === 1 ? now.getFullYear() : now.getFullYear() + 1} Year!`, 
                backgrounds: ['bonus/winter.jpg', 'backgrounds/background03.jpg'] 
            },
            { 
                dates: ['4-22'], 
                message: `Happy ${new Date().getFullYear() - 2010} NieR Anniversary!`, 
                backgrounds: ['bonus/nier_anniversary.png', 'bonus/nier_anniversary_pc.jpg'] 
            },
            { 
                dates: ['2-23'], 
                message: `Happy ${new Date().getFullYear() - 2017} NieR: Automata Anniversary!`, 
                backgrounds: ['backgrounds/android09.jpg', 'bonus/automata_anniversary_pc.jpg'] 
            }
        ]
    };

    let now = new Date();
    const key = `${now.getMonth() + 1}-${now.getDate()}`;
    let selectedBackground;
    
    const event = special['events'].find(item => item.dates.includes(key));

    if (event) {
        selectedBackground = Math.abs(AspectRatio.value - 9 / 16) < Math.abs(AspectRatio.value - 16 / 9)
            ? event.backgrounds[0]
            : event.backgrounds[1];

    } else {
        const backgrounds = Math.abs(AspectRatio.value - 9 / 16) < Math.abs(AspectRatio.value - 16 / 9)
            ? ['backgrounds/android01.jpg', 'backgrounds/android09.jpg']
            : ['backgrounds/background.jpg', 'backgrounds/background02.jpg'];

        selectedBackground = backgrounds[Math.floor(Math.random() * backgrounds.length)];
    }
    const matchingTracks = Object.keys(phrases).filter(key => {
        const track = phrases[key];
        const bg = Object.keys(track.background || {})[0] || '';
        const bgAndroid = Object.keys(track.backgroundAndroid || {})[0] || '';
        return bg === selectedBackground || bgAndroid === selectedBackground;
    });

    if (matchingTracks.length > 0) {
        currentTrackInfo.currentTrackKeywords = matchingTracks[Math.floor(Math.random() * matchingTracks.length)];
    } else {
        currentTrackInfo.currentTrackKeywords = '';
    }
    await changeBackground(selectedBackground);
    await hideLoadingOverlay();
    if (event) {
        const message = typeof event.message === 'function' ? event.message(now) : event.message;
		toggleVisibility();
        showNotification(message);
    }
}

function hideLoadingOverlay() {
    const overlay = document.getElementById('loadingOverlay');
    return new Promise(resolve => {
        setTimeout(() => {
            overlay.classList.add('hide');
            setTimeout(() => {
                overlay.style.display = 'none';
                resolve();
            }, 950);
        }, 350);
    });
}

window.addEventListener('load', async function() {

	await new Promise((resolve, reject) => {
		const script = document.createElement('script');
		script.src = weburl + 'songs.js';
		script.onload = () => {
			console.log(`songs.js loaded from: ${script.src}`);
			resolve();
		};
		script.onerror = () => {
			console.error(`Failed to load songs.js from: ${script.src}`);
			reject(new Error(`Failed to load songs.js from: ${script.src}`));
		};
		document.head.appendChild(script);
	});

	toggleVisibility();
    const savedCountryCode = localStorage.getItem('selectedCountryCode');
    let finalCountryCode;

    if (savedCountryCode) {
        finalCountryCode = savedCountryCode;
        console.log(`Loaded country code from localStorage: ${finalCountryCode}`);
    } else {
        const locationData = await getIpAndLocation();
        finalCountryCode = locationData.country_code;
        localStorage.setItem('selectedCountryCode', finalCountryCode);
        console.log(`Determined country code by IP: ${finalCountryCode}`);
    }

    document.getElementById('countryFlag').src = `${weburl}flags/${finalCountryCode.toLowerCase()}.png`;
    document.getElementById('countryFlag').setAttribute('data-country-code', finalCountryCode);
    console.log(`Country flag set for code: ${finalCountryCode}`);

    await setBackground()
	console.log("Background set")
	updatePrice(finalCountryCode)

    if (globalDiscountPercent && globalDiscountPercent !== 0) {
        showNotification(`NieR:Automata is on sale in ${finalCountryCode}. Discount percent is ${globalDiscountPercent}%`);
    } else {
        console.log("No discount available in your region.");
    }
});

<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>
<!-----------------------------------------------------------------------------------------------------------------------------------------------------!>

    </script>
</body>
</html>